# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19j8VQUbsJom9InwSMh8v3IgCjr0m2AWD
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd  
import numpy as np  
import random as rd
import datetime
import statsmodels.tsa.api as smt 
from statsmodels.tsa.stattools import adfuller
import warnings
import matplotlib.pyplot as plt  
import seaborn as seabornInstance 
from sklearn.model_selection import train_test_split 
from sklearn import metrics
# %matplotlib inline
import seaborn as sns

!pip install prophet

import fbprophet as Prophet

df=pd.read_csv("/content/google-data.csv")

df

df.info()

df.Date.min()

df.Date.max()

df['date']=pd.to_datetime(df["Date"]).dt.strftime("%d/%m/%y")

df.head(2)

df.drop(columns=['Date'],inplace=True)

prices=pd.DataFrame()

prices['date']=pd.date_range(start='2013-01-02',end='2017-12-29')

prices['date']=prices['date'].dt.strftime("%d/%m/%y")
prices=prices.merge(df,how="left",on="date")

numeric=["Open","High","Low","Close","Adj Close","Volume"]

for i in numeric :
  prices[i]=prices[i].interpolate(method="cubic")

prices.info()

import statsmodels.api as sm
additive = sm.tsa.seasonal_decompose(prices.Close.values,freq=365,model="additive") 
figurel = additive.plot() 
multiplicative = sm.tsa.seasonal_decompose(prices.Close.values,freq=365,model="multiplicative") 
figure2 = multiplicative.plot()

model_dataframe = prices.loc[:,['date', 'Close']].rename(columns={"date": "ds", "Close": "y"})
model_dataframe.head()

model=Prophet.Prophet(yearly_seasonality=True,interval_width=0.95)   # Niye 2 defe prophet yazdÄ±m ?
model.fit(model_dataframe)

future=model.make_future_dataframe(periods=100)
forecast=model.predict(future)
forecast[['ds','yhat','yhat_lower','yhat_upper']].tail(2)

plt.figure(figsize=(30,12))
model.plot(forecast,xlabel='Date',ylabel='ClosePrice')
plt.title('Case Study')

fig=model.plot_components(forecast)

from fbprophet.diagnostics import cross_validation 
from fbprophet.diagnostics import performance_metrics 
!pip install bayesian-optimization

def optimization_function(changepoint_prior_scale, seasonality_prior_scale):  
  model = Prophet.Prophet(changepoint_prior_scale=changepoint_prior_scale, seasonality_prior_scale=seasonality_prior_scale) 
  df_cv = cross_validation(model, horizon='300 days', parallel="processes") 
  df_p = performance_metrics(df_cv, rolling_window=1) 
  rmse_score = (df_p['rmse'].values[0]) 
  print(rmse_score) 
  return -rmse_score

from bayes_opt import BayesianOptimization

prophet_params={ 
'changepoint_prior_scale': [0.001, 0.5], 
'seasonality_prior_scale': [0.01,10.01], 
} 
optimizer = BayesianOptimization( 
    f=optimization_function, 
    pbounds=prophet_params, 
    random_state=42, 
)

optimizer.maximize(init_points=2,n_iter=3,)

optimizer.max

optimizer.res







